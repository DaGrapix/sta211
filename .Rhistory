capture.sim(N, pi)
set.seed(32)
N = 950
pi = 0.3
df <- capture.sim(N, pi)
C1 <- df$C1
C2 <- df$C20 + df$C21
a <- 1
b <- 3
a.post <- C1 + C2 + a
b.post <- 2*N - C1 - C2 + b
pi.MLE <- (C1 + C2)/(2*N)
p_val<- seq(0, 1, length.out=100)
plot(p_val, dbeta(p_val, a, b),type="l",col="red",ylab="Density",xlab="pi",main=paste("a=",a,"b=",b),ylim=c(0,40))
points(p_val, dbeta(p_val,a.post,b.post),type="l")
abline(v=pi.MLE)
C1 <- 125
C20 <- 134
C21 <- 21
C2 <- C20 + C21
N.hat <- C1*C2/C21
round(N.hat, 0)
n.iter <- 100
N.true <- 923
pi.true <- 0.15
N.MC <- function(N, pi, n.iter){
df.repeated <- replicate(n.iter, capture.sim(N, pi)) %>% drop() %>% t() %>% as.data.frame()
N.hat.repeated <- apply(df.repeated, MARGIN=1, FUN = function(x) x$C1*(x$C20+x$C21)/x$C21)
df.repeated$N.hat <- N.hat.repeated
N.monte.carlo <- mean(df.repeated$N.hat)
return(N.monte.carlo)
}
N.MC(N.true, pi.true, n.iter)
N.true.seq <- seq(100, 1000, 10)
N.evolution <- sapply(N.true.seq, FUN=function(n) N.MC(n, pi.true,n.iter))
plot(N.true.seq, N.evolution-N.true)
plot(N.true.seq, abs(N.evolution-N.true))
plot(N.true.seq, N.evolution-N.true)
plot(N.true.seq, N.evolution-N.true)
legend(x="N.true", y="N^ - N.true")
plot(N.true.seq, N.evolution-N.true, xlab="N.true")
N.true.seq <- seq(100, 2000, 10)
N.evolution <- sapply(N.true.seq, FUN=function(n) N.MC(n, pi.true,n.iter))
N.true.seq <- seq(100, 1500, 10)
N.evolution <- sapply(N.true.seq, FUN=function(n) N.MC(n, pi.true,n.iter))
N.true.seq <- seq(100, 1000, 10)
N.evolution <- sapply(N.true.seq, FUN=function(n) N.MC(n, pi.true,n.iter))
plot(N.true.seq, N.evolution-N.true, xlab="N.true")
set.seed(57)
N.true.seq <- seq(100, 1000, 10)
N.evolution <- sapply(N.true.seq, FUN=function(n) N.MC(n, pi.true,n.iter))
plot(N.true.seq, N.evolution-N.true, xlab="N.true")
set.seed(57)
N.true.seq <- seq(100, 2000, 10)
N.evolution <- sapply(N.true.seq, FUN=function(n) N.MC(n, pi.true, n.iter))
set.seed(57)
N.true.seq <- seq(100, 900, 10)
N.evolution <- sapply(N.true.seq, FUN=function(n) N.MC(n, pi.true, n.iter))
plot(N.true.seq, N.evolution-N.true, xlab="N.true")
set.seed(57)
N.true.seq <- seq(100, 10000, 100)
N.evolution <- sapply(N.true.seq, FUN=function(n) N.MC(n, pi.true, n.iter))
set.seed(57)
N.true.seq <- seq(100, 1100, 10)
N.evolution <- sapply(N.true.seq, FUN=function(n) N.MC(n, pi.true, n.iter))
N.MC(1000, pi.true, n.iter)
N.MC(10, pi.true, n.iter)
N.MC(100, pi.true, n.iter)
N.MC(100, pi.true, n.iter)
N.MC(10000, pi.true, n.iter)
N=100
df.repeated <- replicate(n.iter, capture.sim(N, pi)) %>% drop() %>% t() %>% as.data.frame()
N.hat.repeated <- apply(df.repeated, MARGIN=1, FUN = function(x) x$C1*(x$C20+x$C21)/x$C21)
df.repeated$N.hat <- N.hat.repeated
N.monte.carlo <- mean(df.repeated$N.hat)
N=100
df.repeated <- replicate(n.iter, capture.sim(N, pi)) %>% drop() %>% t() %>% as.data.frame()
N.hat.repeated <- apply(df.repeated, MARGIN=1, FUN = function(x) x$C1*(x$C20+x$C21)/x$C21)
df.repeated$N.hat <- N.hat.repeated
N.monte.carlo <- mean(df.repeated$N.hat)
N.monte.carlo
N=1
df.repeated <- replicate(n.iter, capture.sim(N, pi)) %>% drop() %>% t() %>% as.data.frame()
N.hat.repeated <- apply(df.repeated, MARGIN=1, FUN = function(x) x$C1*(x$C20+x$C21)/x$C21)
df.repeated$N.hat <- N.hat.repeated
N.monte.carlo <- mean(df.repeated$N.hat)
N.monte.carlo
N=10
df.repeated <- replicate(n.iter, capture.sim(N, pi)) %>% drop() %>% t() %>% as.data.frame()
N.hat.repeated <- apply(df.repeated, MARGIN=1, FUN = function(x) x$C1*(x$C20+x$C21)/x$C21)
df.repeated$N.hat <- N.hat.repeated
N.monte.carlo <- mean(df.repeated$N.hat)
N.monte.carlo
N=100
df.repeated <- replicate(n.iter, capture.sim(N, pi)) %>% drop() %>% t() %>% as.data.frame()
N.hat.repeated <- apply(df.repeated, MARGIN=1, FUN = function(x) x$C1*(x$C20+x$C21)/x$C21)
df.repeated$N.hat <- N.hat.repeated
N.monte.carlo <- mean(df.repeated$N.hat)
N.monte.carlo
N=1000
df.repeated <- replicate(n.iter, capture.sim(N, pi)) %>% drop() %>% t() %>% as.data.frame()
N.hat.repeated <- apply(df.repeated, MARGIN=1, FUN = function(x) x$C1*(x$C20+x$C21)/x$C21)
df.repeated$N.hat <- N.hat.repeated
N.monte.carlo <- mean(df.repeated$N.hat)
N.monte.carlo
N=10000
df.repeated <- replicate(n.iter, capture.sim(N, pi)) %>% drop() %>% t() %>% as.data.frame()
N=1001
df.repeated <- replicate(n.iter, capture.sim(N, pi)) %>% drop() %>% t() %>% as.data.frame()
N.hat.repeated <- apply(df.repeated, MARGIN=1, FUN = function(x) x$C1*(x$C20+x$C21)/x$C21)
df.repeated$N.hat <- N.hat.repeated
N.monte.carlo <- mean(df.repeated$N.hat)
N.monte.carlo
N=1010
df.repeated <- replicate(n.iter, capture.sim(N, pi)) %>% drop() %>% t() %>% as.data.frame()
N.hat.repeated <- apply(df.repeated, MARGIN=1, FUN = function(x) x$C1*(x$C20+x$C21)/x$C21)
df.repeated$N.hat <- N.hat.repeated
N.monte.carlo <- mean(df.repeated$N.hat)
N.monte.carlo
N=1100
df.repeated <- replicate(n.iter, capture.sim(N, pi)) %>% drop() %>% t() %>% as.data.frame()
df.repeated <- replicate(n.iter, capture.sim(N, pi)) %>% drop() %>% t() %>% as.data.frame()
plot(p_val, dbeta(p_val, a, b),type="l",col="red",ylab="Density",xlab="pi",main=paste("a=",a,"b=",b),ylim=c(0,40))
points(p_val, dbeta(p_val,a.post,b.post),type="l")
abline(v=pi.MLE, color="green")
plot(p_val, dbeta(p_val, a, b),type="l",col="red",ylab="Density",xlab="pi",main=paste("a=",a,"b=",b),ylim=c(0,40))
points(p_val, dbeta(p_val,a.post,b.post),type="l")
abline(v=pi.MLE, color="blue")
plot(p_val, dbeta(p_val, a, b),type="l",col="red",ylab="Density",xlab="pi",main=paste("a=",a,"b=",b),ylim=c(0,40))
points(p_val, dbeta(p_val,a.post,b.post),type="l")
abline(v=pi.MLE)
legend()
?legend()
plot(p_val, dbeta(p_val, a, b),type="l",col="red",ylab="Density",xlab="pi",main=paste("a=",a,"b=",b),ylim=c(0,40))
points(p_val, dbeta(p_val,a.post,b.post),type="l")
abline(v=pi.MLE)
legend("topright", legend=c("a posteriori", "a priori", TeX("$\\hat{\\lambda}_{MLE}$")), bty='n', pch=rep('_',3), col=c(2,4,1))
plot(p_val, dbeta(p_val, a, b),type="l",col="red",ylab="Density",xlab="pi",main=paste("a=",a,"b=",b),ylim=c(0,40))
curve(p_val, dbeta(p_val,a.post,b.post),type="l")
plot(p_val, dbeta(p_val, a, b),type="l",col="red",ylab="Density",xlab="pi",main=paste("a=",a,"b=",b),ylim=c(0,40))
curve(p_val, dbeta(p_val,a.post,b.post),add=TRUE)
a <- 1
b <- 3
a.post <- C1 + C2 + a
b.post <- 2*N - C1 - C2 + b
pi.MLE <- (C1 + C2)/(2*N)
p_val<- seq(0, 1, length.out=100)
plot(p_val, dbeta(p_val, a, b),type="l",col="red",ylab="Density",xlab="pi",main=paste("a=",a,"b=",b),ylim=c(0,40))
curve(p_val, dbeta(p_val,a.post,b.post),add=TRUE)
p_val<- seq(0, 1, length.out=100)
plot(p_val, dbeta(p_val, a, b),type="l",col="red",ylab="Density",xlab="pi",main=paste("a=",a,"b=",b),ylim=c(0,40))
curve(dbeta(p_val,a.post,b.post),add=TRUE)
plot(p_val, dbeta(p_val, a, b),type="l",col="red",ylab="Density",xlab="pi",main=paste("a=",a,"b=",b),ylim=c(0,40))
curve(dbeta(x,a.post,b.post),add=TRUE)
abline(v=pi.MLE)
legend("topright", legend=c("a posteriori", "a priori", TeX("$\\hat{\\lambda}_{MLE}$")), bty='n', pch=rep('_',3), col=c(2,4,1))
plot(p_val, dbeta(p_val, a, b),type="l",col="red",ylab="Density",xlab="pi",main=paste("a=",a,"b=",b),ylim=c(0,40))
curve(dbeta(x,a.post,b.post),add=TRUE)
abline(v=pi.MLE)
legend("topright", legend=c("a posteriori", "a priori", "max.vraiss"), bty='n', pch=rep('_',3), col=c(2,4,1))
plot(p_val, dbeta(p_val, a, b),type="l",col="red",ylab="Density",xlab="pi",main=paste("a=",a,"b=",b),ylim=c(0,50))
curve(dbeta(x,a.post,b.post),add=TRUE)
abline(v=pi.MLE)
legend("topright", legend=c("a posteriori", "a priori", "max.vraiss"), bty='n', pch=rep('_',3), col=c(2,4,1))
plot(p_val, dbeta(p_val, a, b),type="l",col="red",ylab="Density",xlab="pi",main=paste("a=",a,"b=",b),ylim=c(0,70))
curve(dbeta(x,a.post,b.post),add=TRUE)
abline(v=pi.MLE)
legend("topright", legend=c("a posteriori", "a priori", "max.vraiss"), bty='n', pch=rep('_',3), col=c(2,4,1))
plot(p_val, dbeta(p_val, a, b),type="l",col="red",ylab="Density",xlab="pi",main=paste("a=",a,"b=",b),ylim=c(0,60))
curve(dbeta(x,a.post,b.post),add=TRUE)
abline(v=pi.MLE)
legend("topright", legend=c("a posteriori", "a priori", "max.vraiss"), bty='n', pch=rep('_',3), col=c(2,4,1))
plot(p_val, dbeta(p_val, a, b),type="l",col="red",ylab="Density",xlab="pi",main=paste("a=",a,"b=",b),ylim=c(0,55))
curve(dbeta(x,a.post,b.post),add=TRUE)
abline(v=pi.MLE)
legend("topright", legend=c("a posteriori", "a priori", "max.vraiss"), bty='n', pch=rep('_',3), col=c(2,4,1))
plot(p_val, dbeta(p_val, a, b),type="l",col="red",ylab="Density",xlab="pi",main=paste("a=",a,"b=",b),ylim=c(0,55))
curve(dbeta(x,a.post,b.post),add=TRUE)
abline(v=pi.MLE)
legend("topright", legend=c("a priori", "a posteriori", "max.vraiss"), bty='n', pch=rep('_',3), col=c(2,4,1))
plot(p_val, dbeta(p_val, a, b),type="l",col="red",ylab="Density",xlab="pi",main=paste("a=",a,"b=",b),ylim=c(0,55))
curve(dbeta(x,a.post,b.post),add=TRUE, col="blue")
abline(v=pi.MLE)
legend("topright", legend=c("a priori", "a posteriori", "max.vraiss"), bty='n', pch=rep('_',3), col=c(2,4,1))
plot(p_val, dbeta(p_val, a, b),type="l",col="red",ylab="Density",xlab="pi",main=paste("a=",a,"b=",b),ylim=c(0,55))
curve(dbeta(x,a.post,b.post),add=TRUE, col="blue")
abline(v=pi.MLE)
legend("topright", legend=c("a priori", "a posteriori", "max.vraiss"), bty='n', pch=rep('_',3), col=c("red",4,1))
plot(p_val, dbeta(p_val, a, b),type="l",col="red",ylab="Density",xlab="pi",main=paste("a=",a,"b=",b),ylim=c(0,55))
curve(dbeta(x,a.post,b.post),add=TRUE, col="blue")
abline(v=pi.MLE)
legend("topright", legend=c("a priori", "a posteriori", "max.vraiss"), bty='n', pch=rep('_',3), col=c("red","blue","black"))
plot(p_val, dbeta(p_val, a, b),type="l",col="red",ylab="Densité",xlab="pi",main=paste("a=",a,"b=",b),ylim=c(0,55))
curve(dbeta(x,a.post,b.post),add=TRUE, col="blue")
abline(v=pi.MLE)
legend("topright", legend=c("a priori", "a posteriori", "max.vraiss"), bty='n', pch=rep('_',3), col=c("red","blue","black"))
step(1, 10, 2)
seq(1, 10, 2)
?runif
?rbeta
discrete uniform law
?runif
runif(1, -5, 5)
dunif(1, -5, 5)
dunif(1, -5, 5)
dunif(1, -5, 5)
dunif(1, -5, 5)
dunif(1, -5, 5, log=TRUE)
ddunif(1, -5, 5, log=TRUE)
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
library(extraDistr)
install.packages(extraDistr)
install.packages("extraDistr")
ddunif(1, -5, 5, log=TRUE)
ddunif(1, -5, 5)
library(extraDistr)
ddunif(1, -5, 5)
ddunif(1, -5, 5)
ddunif(1, -5, 5)
ddunif(1, -5, 5)
?ddunif
rdunif
rdunif(1, -5, 5)
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
set.seed(125)
k.seq <- seq(1, 301, 10)
n.iter <- 10000
a <- 1
b <- 3
y <- c(C1=125, C20=134, C21=21)
pi.0 <- 0
theta.0 <- c(pi.0=rbeta(n=1, shape1=a, shape2=b), N.0=1000)
#MCMC(theta.0, y, pi, n.iter, 1, 3, 5)
plot.k.accept.rate(k.seq, theta.0, n.iter, y, a, b)
rm(list=ls())
library(tibble)
library(ggplot2)
library(tidyverse)
set.seed(32)
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
my.qbinom <- function(u, N, pi){
p <- sapply(c(0:N), FUN=function(n) choose(N, n)*pi^n*(1-pi)^{N-n})
cdf <- cumsum(p)
return(findInterval(u, cdf))
}
my.rbinom <- function(N, pi, n.iter=1){
U <- runif(n=n.iter, min=0, max=1)
res <- sapply(U, FUN=function(u) my.qbinom(u,N, pi))
return(res)
}
n.iter <- 10000
N <- 125
pi <- 0.15
generated.C1 <- my.rbinom(N, pi, n.iter)
resultats <- data.frame(n=1:n.iter, valeurs=factor(generated.C1, levels = 0:N))
#frequence theorique
freq_theo =dbinom(0:N, N, pi)
#calcul de la frequence empirique
freq_emp <- c()
for (k in 0:N){
freq_emp <- c(freq_emp, mean(generated.C1==k))
}
freq_binom <- tibble( x=0:N, freq_emp=freq_emp, freq_theo=freq_theo)
#Représentation graphique
ggplot(freq_binom) + #Tableau représenter
aes(x = x) + #Abscisse commune
geom_col(mapping = aes(y = freq_emp), #Ordonne des frquences empiriques
width = 0.2, fill = "lightblue") +
geom_point(aes(y = freq_theo), #On ajoute le point des frquences thoriques
shape = 3, col = "red", size = 3) +
xlim(0, 40) +
labs(y = "Frequence", x = "Nombre de succes")
capture.sim <- function(N, pi){
C1 <- my.rbinom(N=N, pi=pi)
C20 <- my.rbinom(N=N-C1, pi=pi)
C21 <- my.rbinom(N=C1, pi=pi)
return(list(C1=C1, C20=C20, C21=C21))
}
capture.sim(N, pi) %>% as.data.frame()
curve(dbeta(x, 1, 3))
set.seed(32)
N = 950
pi = 0.3
df <- capture.sim(N, pi)
C1 <- df$C1
C2 <- df$C20 + df$C21
a <- 1
b <- 3
a.post <- C1 + C2 + a
b.post <- 2*N - C1 - C2 + b
pi.MLE <- (C1 + C2)/(2*N)
p_val<- seq(0, 1, length.out=100)
plot(p_val, dbeta(p_val, a, b),type="l",col="red",ylab="Densité",xlab="pi",
main=paste("a=",a,"b=",b),ylim=c(0,55))
curve(dbeta(x,a.post,b.post),add=TRUE, col="blue")
abline(v=pi.MLE)
legend("topright", legend=c("a priori", "a posteriori", "max.vraiss"), bty='n',
pch=rep('_',3), col=c("red","blue","black"))
C1 <- 125
C20 <- 134
C21 <- 21
C2 <- C20 + C21
N.hat <- C1*C2/C21
round(N.hat, 0)
n.iter <- 100
N.true <- 923
pi.true <- 0.15
N.MC <- function(N, pi, n.iter){
df.repeated <-
replicate(n.iter, capture.sim(N, pi)) %>% drop() %>% t() %>% as.data.frame()
N.hat.repeated <- apply(df.repeated, MARGIN=1,
FUN = function(x) x$C1*(x$C20+x$C21)/x$C21)
df.repeated$N.hat <- N.hat.repeated
N.monte.carlo <- mean(df.repeated$N.hat)
return(N.monte.carlo)
}
N.MC(N.true, pi.true, n.iter)
set.seed(57)
N.true.seq <- seq(100, 1000, 10)
N.evolution <- sapply(N.true.seq, FUN=function(n) N.MC(n, pi.true, n.iter))
plot(N.true.seq, N.evolution-N.true, xlab="N.true")
N.law <- function(N, pi, c1, c20){
density <- choose(N, c1+c20)*(1-pi)^(2*N)
return(density)
}
MCMC <- function(theta.0, y, pi.0, n.iter, a, b, k){
c1 <- y[1]
c20 <- y[2]
c21 <- y[3]
c2 <- c20 + c21
pi.0 <- theta.0[1]
N.0 <- theta.0[2]
chain <- matrix(0, nrow=n.iter, ncol=2, dimnames=list(NULL,c("pi","N")))
accept <- vector("numeric", n.iter)
chain[1, 1:2] <- theta.0
accept[1] <- 1
N.curr <- N.0
pi.curr <- pi.0
oldlik <- N.law(N.curr, pi.curr, c1, c20)
for (i in 2:n.iter){
#on tire dans la loi conditionnelle complète de pi
pi.curr <- rbeta(n=1, shape1=c1+c2+a, shape2=2*N.curr-c1-c2+b)
#loi uniforme discrète
innov <- sample(-k:k, size=1)
N.cand <- N.curr + innov
lik <- N.law(N.cand, pi.curr, c1, c20)
r <- lik/oldlik
u <- runif(1)
if (u<r){
N.curr <- N.cand
oldlik <- lik
accept[i] <- 1
}
chain[i,] <- c(pi.curr, N.curr)
}
return(list(chain=chain, taux.accept=mean(accept)))
}
plot.k.accept.rate <- function(k.seq, theta.0, n.iter, y, a, b){
accept.rate.evolution <- sapply(k.seq, FUN=function(x){
return(MCMC(theta.0, y, pi.0, n.iter, a, b, x)$taux.accept)})
plot(x=k.seq, y=accept.rate.evolution)
}
set.seed(125)
k.seq <- seq(1, 301, 10)
n.iter <- 10000
a <- 1
b <- 3
y <- c(C1=125, C20=134, C21=21)
pi.0 <- 0
theta.0 <- c(pi.0=rbeta(n=1, shape1=a, shape2=b), N.0=1000)
#MCMC(theta.0, y, pi, n.iter, 1, 3, 5)
plot.k.accept.rate(k.seq, theta.0, n.iter, y, a, b)
##################changer
k.opt <- 1
MCMC <- function(theta.0, y, pi.0, n.iter, a, b, k){
c1 <- y[1]
c20 <- y[2]
c21 <- y[3]
c2 <- c20 + c21
pi.0 <- theta.0[1]
N.0 <- theta.0[2]
chain <- matrix(0, nrow=n.iter, ncol=2, dimnames=list(NULL,c("pi","N")))
accept <- vector("numeric", n.iter)
chain[1, 1:2] <- theta.0
accept[1] <- 1
N.curr <- N.0
pi.curr <- pi.0
oldlik <- N.law(N.curr, pi.curr, c1, c20)
for (i in 2:n.iter){
#on tire dans la loi conditionnelle complète de pi
pi.curr <- rbeta(n=1, shape1=c1+c2+a, shape2=2*N.curr-c1-c2+b)
#loi uniforme discrète
innov <- sample(-k:k, size=1)
N.cand <- N.curr + innov
lik <- N.law(N.cand, pi.curr, c1, c20)
r <- lik/oldlik
u <- runif(1)
if (u>r){
N.curr <- N.cand
oldlik <- lik
accept[i] <- 1
}
chain[i,] <- c(pi.curr, N.curr)
}
return(list(chain=chain, taux.accept=mean(accept)))
}
set.seed(125)
k.seq <- seq(1, 301, 10)
n.iter <- 10000
a <- 1
b <- 3
y <- c(C1=125, C20=134, C21=21)
pi.0 <- 0
theta.0 <- c(pi.0=rbeta(n=1, shape1=a, shape2=b), N.0=1000)
#MCMC(theta.0, y, pi, n.iter, 1, 3, 5)
plot.k.accept.rate(k.seq, theta.0, n.iter, y, a, b)
##################changer
k.opt <- 1
y
y[C1]
y$C1
y[[C1]]
names(y)
k.seq
set.seed(5)
k.seq <- seq(1, 301, 10)
n.iter <- 10000
a <- 1
b <- 3
y <- c(C1=125, C20=134, C21=21)
pi.0 <- 0
theta.0 <- c(pi.0=rbeta(n=1, shape1=a, shape2=b), N.0=1000)
#MCMC(theta.0, y, pi, n.iter, 1, 3, 5)
plot.k.accept.rate(k.seq, theta.0, n.iter, y, a, b)
set.seed(125)
k.seq <- seq(1, 301, 10)
n.iter <- 10000
a <- 1
b <- 3
y <- c(C1=125, C20=134, C21=21)
pi.0 <- 0
theta.0 <- c(pi.0=rbeta(n=1, shape1=a, shape2=b), N.0=1000)
#MCMC(theta.0, y, pi, n.iter, 1, 3, 5)
plot.k.accept.rate(k.seq, theta.0, n.iter, y, a, b)
##################changer
k.opt <- 1
MCMC <- function(theta.0, y, pi.0, n.iter, a, b, k){
c1 <- y[1]
c20 <- y[2]
c21 <- y[3]
c2 <- c20 + c21
pi.0 <- theta.0[1]
N.0 <- theta.0[2]
chain <- matrix(0, nrow=n.iter, ncol=2, dimnames=list(NULL,c("pi","N")))
accept <- vector("numeric", n.iter)
chain[1, 1:2] <- theta.0
accept[1] <- 1
N.curr <- N.0
pi.curr <- pi.0
oldlik <- N.law(N.curr, pi.curr, c1, c20)
for (i in 2:n.iter){
#on tire dans la loi conditionnelle complète de pi
pi.curr <- rbeta(n=1, shape1=c1+c2+a, shape2=2*N.curr-c1-c2+b)
#loi uniforme discrète
N.cand <- N.curr + sample(-k:k, size=1)
lik <- N.law(N.cand, pi.curr, c1, c20)
r <- lik/oldlik
u <- runif(1)
if (u<r){
N.curr <- N.cand
oldlik <- lik
accept[i] <- 1
}
chain[i,] <- c(pi.curr, N.curr)
}
return(list(chain=chain, taux.accept=mean(accept)))
}
set.seed(125)
k.seq <- seq(1, 301, 10)
n.iter <- 10000
a <- 1
b <- 3
y <- c(C1=125, C20=134, C21=21)
pi.0 <- 0
theta.0 <- c(pi.0=rbeta(n=1, shape1=a, shape2=b), N.0=1000)
#MCMC(theta.0, y, pi, n.iter, 1, 3, 5)
plot.k.accept.rate(k.seq, theta.0, n.iter, y, a, b)
##################changer
k.opt <- 1
set.seed(5)
k.seq <- seq(1, 301, 10)
n.iter <- 10000
a <- 1
b <- 3
y <- c(C1=125, C20=134, C21=21)
pi.0 <- 0
theta.0 <- c(pi.0=rbeta(n=1, shape1=a, shape2=b), N.0=1000)
#MCMC(theta.0, y, pi, n.iter, 1, 3, 5)
plot.k.accept.rate(k.seq, theta.0, n.iter, y, a, b)
##################changer
k.opt <- 1
set.seed(57)
N.true.seq <- seq(100, 1000, 10)
N.evolution <- sapply(N.true.seq, FUN=function(n) N.MC(n, pi.true, n.iter) %>% abs())
plot(N.true.seq, N.evolution-N.true, xlab="N.true")
set.seed(57)
N.true.seq <- seq(100, 1000, 10)
N.evolution <- sapply(N.true.seq, FUN=function(n) abs(N.MC(n, pi.true, n.iter)))
plot(N.true.seq, N.evolution-N.true, xlab="N.true")
set.seed(57)
N.true.seq <- seq(100, 1000, 10)
N.evolution <- sapply(N.true.seq, FUN=function(n) N.MC(n, pi.true, n.iter))
